import { v } from "convex/values";
import { action } from "./_generated/server";
import { GoogleGenAI, Type } from "@google/genai";

// Helper to initialize AI
const getAI = () => {
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) throw new Error("Server API Key missing");
    return new GoogleGenAI({ apiKey });
};
// Trigger linter

export const chat = action({
    args: {
        prompt: v.any(),
        systemInstruction: v.optional(v.string()),
        responseMimeType: v.optional(v.string()),
        responseSchema: v.optional(v.any()),
        tools: v.optional(v.any()),
        modelName: v.optional(v.string()),
        provider: v.optional(v.string()),
    },
    handler: async (ctx, args) => {
        // Default to Gemini
        const ai = getAI();
        const modelName = args.modelName || "gemini-2.5-flash";

        // Handle prompt format
        let contents;
        if (typeof args.prompt === 'string') {
            contents = args.prompt;
        } else {
            contents = args.prompt;
        }

        try {
            const response = await ai.models.generateContent({
                model: modelName,
                contents: contents,
                config: {
                    systemInstruction: args.systemInstruction,
                    responseMimeType: args.responseMimeType,
                    responseSchema: args.responseSchema,
                    tools: args.tools && args.tools.length > 0 ? args.tools : undefined
                },
            });

            return response.text || "";
        } catch (error: any) {
            console.error("AI Backend Error:", error);
            throw new Error(error.message || "AI Error");
        }
    }
});

const SYSTEM_INSTRUCTION = `You are an expert startup consultant and venture capitalist. 
Your goal is to help founders refine their business models using the Lean Canvas framework and create compelling pitch decks.
Be concise, punchy, and professional.`;

// Helper for delay
const wait = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

const callAI = async (
    prompt: string | { role: string, parts: any[] }[],
    systemInstruction: string,
    responseMimeType?: string,
    responseSchema?: any,
    retryCount = 0,
    tools: any[] = [],
    modelName: string = "gemini-2.5-flash"
): Promise<string> => {
    try {
        const ai = getAI();

        let contents;
        if (typeof prompt === 'string') {
            contents = prompt;
        } else {
            contents = prompt;
        }

        const response = await ai.models.generateContent({
            model: modelName,
            contents: contents,
            config: {
                systemInstruction: systemInstruction,
                responseMimeType: responseMimeType,
                responseSchema: responseSchema,
                tools: tools.length > 0 ? tools : undefined
            },
        });

        return response.text || "";

    } catch (error: any) {
        const errorCode = error.status || error.code || error?.error?.code;
        const errorMessage = error.message || JSON.stringify(error);

        const isRateLimit =
            errorCode === 429 ||
            errorCode === 'RESOURCE_EXHAUSTED' ||
            errorMessage.includes('429') ||
            errorMessage.includes('quota') ||
            errorMessage.includes('RESOURCE_EXHAUSTED');

        if (isRateLimit && retryCount < 3) {
            const delay = Math.pow(2, retryCount + 1) * 1000 + Math.random() * 500;
            console.warn(`Rate limit hit (${errorCode}). Retrying in ${Math.round(delay)}ms...`);
            await wait(delay);
            return callAI(prompt, systemInstruction, responseMimeType, responseSchema, retryCount + 1, tools, modelName);
        }

        console.error("AI Service Error:", error);
        throw error;
    }
};

export const suggestCanvasSection = action({
    args: {
        section: v.string(),
        startupName: v.string(),
        hypothesis: v.string(),
        canvasContext: v.string(), // JSON string of canvas
        modelName: v.optional(v.string())
    },
    handler: async (ctx, args) => {
        const prompt = `
        Based on the startup idea below, provide 3-4 bullet points for the "${args.section}" section of a Lean Canvas.
        
        Startup Name: ${args.startupName}
        Initial Hypothesis/Idea: ${args.hypothesis}
        
        Context from other sections (if available):
        ${args.canvasContext}
        
        Return only the content for the section.
        `;

        return callAI(prompt, SYSTEM_INSTRUCTION, undefined, undefined, 0, [], args.modelName);
    }
});

export const generatePitchDeck = action({
    args: {
        startupData: v.any(), // Passing full object for simplicity, or we can pass JSON string
        modelName: v.optional(v.string())
    },
    handler: async (ctx, args) => {
        const data = args.startupData;

        // Include financial data in the prompt context
        const financialContext = `
            Financial Model:
            - Type: ${data.revenueModel.businessModelType}
            - Revenue Streams: ${data.revenueModel.revenueStreams.map((s: any) => s.name + " ($" + s.price + ")").join(", ")}
            - Cost Structure: ${data.revenueModel.costStructure.map((c: any) => c.name + " ($" + c.amount + ")").join(", ")}
            - Key Metrics: Growth ${data.revenueModel.monthlyGrowthRate}%, Churn ${data.revenueModel.churnRate}%, CAC $${data.revenueModel.cac}
        `;

        // Include Market Data
        const marketContext = `
            Market Research:
            - TAM (Total Addressable Market): ${data.market.tam}
            - SAM (Serviceable Available Market): ${data.market.sam}
            - SOM (Serviceable Obtainable Market): ${data.market.som}
        `;

        // Include Competitor Data
        const competitorContext = `
            Competitor Analysis:
            - Competitors: ${data.competitorAnalysis.competitors.map((c: any) => c.name).join(', ')}
            - Differentiation/Summary: ${data.competitorAnalysis.analysisSummary}
        `;

        const prompt = `
            Create a professional 10-slide pitch deck for the following startup.
            Use all provided context to make it specific and data-driven.
        
            Startup Name: ${data.name}
            Hypothesis: ${data.hypothesis}
            
            DATA SOURCES:
            Lean Canvas: ${JSON.stringify(data.canvas)}
            ${financialContext}
            ${marketContext}
            ${competitorContext}
            
            Return a valid JSON array of objects. Each object should have:
            - id: string (unique)
            - title: string (slide headline)
            - content: string (bullet points or main text, formatted with Markdown)
            - notes: string (speaker notes)
            - imagePrompt: string (a description of a visual to accompany this slide)
            
            SLIDE STRUCTURE:
            1. Title Slide
            2. Problem (Use Canvas data)
            3. Solution (Use Canvas data)
            4. Market Size (Use TAM/SAM/SOM from Market Research)
            5. Competition (Use Competitor Analysis)
            6. Business Model (Use Financial/Revenue data)
            7. Go-To-Market (Use Channels from Canvas)
            8. Traction/Roadmap
            9. Team (Placeholder)
            10. The Ask / Financial Projections
        
            IMPORTANT: The response MUST be a raw JSON array. Do not wrap in markdown code blocks.
        `;

        try {
            const text = await callAI(prompt, SYSTEM_INSTRUCTION, "application/json",
                {
                    type: Type.ARRAY,
                    items: {
                        type: Type.OBJECT,
                        properties: {
                            id: { type: Type.STRING },
                            title: { type: Type.STRING },
                            content: { type: Type.STRING },
                            notes: { type: Type.STRING },
                            imagePrompt: { type: Type.STRING },
                        },
                        required: ["id", "title", "content", "notes"],
                    },
                },
                0, [], args.modelName
            );

            const cleanText = text.replace(/```json/g, '').replace(/```/g, '').trim();
            return JSON.parse(cleanText);
        } catch (error) {
            console.error("Error generating deck:", error);
            return [];
        }
    }
});

export const analyzeRevenueModel = action({
    args: {
        startupData: v.any(),
        modelName: v.optional(v.string())
    },
    handler: async (ctx, args) => {
        const data = args.startupData;
        const prompt = `
          Analyze the financial projections for this startup.
          
          Startup: ${data.name}
          Business Model: ${data.revenueModel.businessModelType}
          Revenue Streams: ${JSON.stringify(data.revenueModel.revenueStreams)}
          Cost Structure: ${JSON.stringify(data.revenueModel.costStructure)}
          Metrics: Growth ${data.revenueModel.monthlyGrowthRate}%, Churn ${data.revenueModel.churnRate}%, CAC $${data.revenueModel.cac}.
          
          Provide a 2-sentence summary of the financial health and 1 key recommendation.
          Focus on when they might become profitable or if the burn rate is sustainable.
        `;

        return callAI(prompt, SYSTEM_INSTRUCTION, undefined, undefined, 0, [], args.modelName);
    }
});


export const generateMarketResearch = action({
    args: {
        startupData: v.any(),
        attachedFiles: v.optional(v.array(v.object({
            name: v.string(),
            data: v.string(),
            mimeType: v.string()
        }))),
        keywords: v.optional(v.array(v.string())),
        modelName: v.optional(v.string())
    },
    handler: async (ctx, args) => {
        const data = args.startupData;
        const attachedFiles = args.attachedFiles || [];
        const keywords = args.keywords || [];

        const jsonExample = `
        {
            "report": "Markdown text...",
            "tam": 1000000000,
            "sam": 500000000,
            "som": 10000000
        }
        `;

        const textPrompt = `
            Conduct a deep market research analysis for the following startup.
            
            Startup Name: ${data.name}
            Hypothesis: ${data.hypothesis}
            Problem: ${data.canvas['Problem'] || 'Not specified'}
            Customer Segments: ${data.canvas['Customer Segments'] || 'Not specified'}
            Solution: ${data.canvas['Solution'] || 'Not specified'}
            
            ${keywords.length > 0 ? `FOCUS KEYWORDS: ${keywords.join(', ')}. Ensure the research specifically targets these topics in your analysis.` : ""}
    
            ${attachedFiles.length > 0 ? `IMPORTANT - ATTACHED FILE CONTEXT: You have access to ${attachedFiles.length} uploaded files (PDF/TXT). You MUST read and summarize key details from these files.` : ""}
    
            TASK:
            1. Use your knowledge to estimate the latest 2024/2025 market data for this industry/sector.
            2. If files are attached, extract specific market numbers, quotes, or trends from them and explicitly mention "According to the uploaded document..." in the report.
            3. Generate a "White Paper" style market research report (Markdown format). Use realistic estimates.
            4. Estimate TAM, SAM, SOM in USD (integers). Use reasonable industry benchmarks.
            5. IMPORTANT: Include a "Sources & References" section at the end, and where possible, cite sources inline with [Link Name](url). If exact URLs aren't known, cite the organization or report name.
    
            FORMAT YOUR RESPONSE AS FOLLOWS:
            
            [Start with the Markdown Report]
            # Market Research Report
            ... content ...

            [At the very end, output the numbers in this exact JSON block]
            \`\`\`json
            {
                "tam": 1000000000,
                "sam": 500000000,
                "som": 10000000
            }
            \`\`\`
        `;

        // Construct request parts (Text + optional Files for multimodal)
        let parts: any[] = [{ text: textPrompt }];

        if (attachedFiles.length > 0) {
            attachedFiles.forEach((file: any) => {
                parts.push({
                    inlineData: {
                        mimeType: file.mimeType,
                        data: file.data
                    }
                });
            });
        }

        const geminiContents = [{ role: 'user', parts: parts }];

        try {
            // Call AI requesting TEXT response (since we want Markdown + JSON block)
            const text = await callAI(
                geminiContents,
                "You are a top-tier market researcher with extensive knowledge of industry trends and market sizing.",
                "text/plain", // Changed from application/json to text
                undefined,
                0,
                [],
                args.modelName || "gemini-2.5-flash"
            );

            // Extract JSON block for numbers
            let parsedTam = 0;
            let parsedSam = 0;
            let parsedSom = 0;
            let finalReport = text;

            const jsonMatch = text.match(/```json\s*(\{[\s\S]*?\})\s*```/);

            if (jsonMatch) {
                try {
                    const jsonBlock = jsonMatch[1];
                    const parsed = JSON.parse(jsonBlock);

                    // Handle numbers that might be strings or numbers
                    const parseNum = (val: any) => {
                        if (typeof val === 'number') return val;
                        if (typeof val === 'string') {
                            return parseFloat(val.replace(/,/g, '').replace(/\$/g, '')) || 0;
                        }
                        return 0;
                    };

                    parsedTam = parseNum(parsed.tam);
                    parsedSam = parseNum(parsed.sam);
                    parsedSom = parseNum(parsed.som);

                    // Remove the JSON block from the report text to keep it clean
                    finalReport = text.replace(jsonMatch[0], '').trim();

                } catch (e) {
                    console.log("Failed to parse JSON block from response");
                }
            } else {
                // Fallback: Try to find JSON without code blocks if AI forgot them
                const rawJsonMatch = text.match(/\{[\s\S]*"tam"[\s\S]*\}/);
                if (rawJsonMatch) {
                    try {
                        const parsed = JSON.parse(rawJsonMatch[0]);
                        parsedTam = parsed.tam || 0;
                        parsedSam = parsed.sam || 0;
                        parsedSom = parsed.som || 0;
                        // Remove JSON from report
                        finalReport = text.replace(rawJsonMatch[0], '').trim();
                    } catch (e) { }
                }
            }

            // Fallback extraction if JSON parsing failed or returned empty values
            const extractNumber = (pattern: RegExp): number => {
                const match = text.match(pattern);
                if (match) {
                    const numStr = match[1].replace(/,/g, '').replace(/\s/g, '');
                    if (numStr.includes('trillion')) return parseFloat(numStr) * 1000000000000;
                    if (numStr.includes('billion')) return parseFloat(numStr) * 1000000000;
                    if (numStr.includes('million')) return parseFloat(numStr) * 1000000;
                    return parseFloat(numStr);
                }
                return 0;
            };

            // Use parsed values or fallback to regex extraction
            const tam = parsedTam || extractNumber(/TAM[:\s]*\$?\s*([0-9.,]+\s*(?:trillion|billion|million)?)/i) ||
                extractNumber(/Total Addressable Market[:\s]*\$?\s*([0-9.,]+\s*(?:trillion|billion|million)?)/i) ||
                404000000000;

            const sam = parsedSam || extractNumber(/SAM[:\s]*\$?\s*([0-9.,]+\s*(?:trillion|billion|million)?)/i) ||
                extractNumber(/Serviceable Available Market[:\s]*\$?\s*([0-9.,]+\s*(?:trillion|billion|million)?)/i) ||
                7820000000;

            const som = parsedSom || extractNumber(/SOM[:\s]*\$?\s*([0-9.,]+\s*(?:trillion|billion|million)?)/i) ||
                extractNumber(/Serviceable Obtainable Market[:\s]*\$?\s*([0-9.,]+\s*(?:trillion|billion|million)?)/i) ||
                391000000;

            return {
                report: finalReport,
                tam: tam,
                sam: sam,
                som: som
            };
        } catch (error) {
            console.error("Error generating market research:", error);
            return {
                report: "Error generating report. Please try again.",
                tam: 0,
                sam: 0,
                som: 0
            };
        }
    }
});

export const generateCompetitorAnalysis = action({
    args: {
        startupData: v.any(),
        modelName: v.optional(v.string())
    },
    handler: async (ctx, args) => {
        const data = args.startupData;

        // Check if user has already defined columns/competitors
        const existingAttributes = data.competitorAnalysis.attributes;
        const existingCompetitors = data.competitorAnalysis.competitors;

        let columnsInstruction = "";
        if (existingAttributes.length > 0) {
            columnsInstruction = `
            Use EXACTLY the following attributes (columns) for the analysis: ${JSON.stringify(existingAttributes)}. 
            Do not add new columns. Fill in the data for these specific attributes.
            `;
        } else {
            columnsInstruction = `
            Identify 4 key attributes to compare them on (e.g. Price, Ease of Use, Features, Market Focus).
            IMPORTANT: Include "Differentiation" as one of the columns/attributes.
            `;
        }

        let competitorsInstruction = "";
        if (existingCompetitors.length > 0) {
            const compNames = existingCompetitors.map((c: any) => c.name).filter((n: string) => !n.includes("(Us)") && n !== "New Competitor");
            competitorsInstruction = `
            Analyze these specific competitors that the user has added: ${compNames.join(', ')}.
            Also include "${data.name} (Us)" as the last row.
            Use your browsing/retrieval capabilities to find REAL, up-to-date data for these companies. Do not hallucinate.
            If a competitor is new or unknown, infer likely traits based on the industry standard.
            `;
        } else {
            competitorsInstruction = `
            Identify 3-5 potential direct or indirect competitors (real companies) for this startup idea.
            Use your browsing/retrieval capabilities to find REAL companies that exist today.
            Also include "${data.name} (Us)" as the last row.
            `;
        }

        const prompt = `
            Perform a comprehensive competitive analysis for this startup.
            
            Startup: ${data.name}
            Hypothesis: ${data.hypothesis}
            Problem: ${data.canvas['Problem']}
            Solution: ${data.canvas['Solution']}
            Unique Value Prop: ${data.canvas['Unique Value Proposition']}
    
            INSTRUCTIONS:
            1. ${competitorsInstruction}
            2. ${columnsInstruction}
            3. Create a matrix.
            4. Write a brief summary of the competitive landscape.
    
            Return JSON format:
            {
              "attributes": ["Attribute 1", "Attribute 2", ...],
              "competitors": [
                 { "name": "Competitor A", "Attribute 1": "Value", "Attribute 2": "Value" ... },
                 ...
                 { "name": "${data.name} (Us)", "Attribute 1": "Value", ... }
              ],
              "analysisSummary": "Summary text..."
            }
        `;

        try {
            const text = await callAI(prompt, "You are a strategic analyst. You must use real-world data found via search/retrieval where possible.", "application/json", undefined, 0, [], args.modelName);

            const cleanText = text.replace(/```json/g, '').replace(/```/g, '').trim();
            const result = JSON.parse(cleanText);

            // Post-process to ensure IDs
            if (result.competitors) {
                result.competitors = result.competitors.map((c: any) => ({
                    ...c,
                    id: c.id || Date.now() + Math.random().toString()
                }));
            }

            return result;

        } catch (error) {
            console.error("Error generating competitor analysis:", error);
            return {
                attributes: existingAttributes.length > 0 ? existingAttributes : ["Price", "Features"],
                competitors: existingCompetitors,
                analysisSummary: "Error generating analysis. Check API limits."
            };
        }
    }
});

export const analyzeCustomerFeedback = action({
    args: {
        interview: v.any(),
        modelName: v.optional(v.string())
    },
    handler: async (ctx, args) => {
        const interview = args.interview;
        const prompt = `
            Analyze this customer interview/feedback notes.
            
            Data: ${JSON.stringify(interview)}
            
            1. Determine sentiment (Positive, Neutral, Negative).
            2. Extract a 1-sentence insight or persona summary.
            3. Extract 2-3 key tags.
            
            Return JSON: { "sentiment": "...", "aiAnalysis": "Summary... [Tag1, Tag2]" }
        `;

        try {
            const text = await callAI(prompt, "You are a UX researcher.", "application/json",
                {
                    type: Type.OBJECT,
                    properties: {
                        sentiment: { type: Type.STRING, enum: ["Positive", "Neutral", "Negative"] },
                        aiAnalysis: { type: Type.STRING }
                    },
                    required: ["sentiment", "aiAnalysis"]
                },
                0, [], args.modelName
            );
            return JSON.parse(text.replace(/```json/g, '').replace(/```/g, '').trim());
        } catch (e) {
            return { sentiment: 'Neutral', aiAnalysis: 'Analysis failed.' };
        }
    }
});

export const generateProjectReport = action({
    args: {
        startupData: v.any(),
        modelName: v.optional(v.string())
    },
    handler: async (ctx, args) => {
        const data = args.startupData;
        const prompt = `
            Generate a comprehensive White Paper report for this startup.
            The report should look like a professional business document (using Markdown).
            
            Startup Name: ${data.name}
            Original Idea: ${data.hypothesis}
            
            DATA TO ANALYZE:
            1. Canvas Evolution (Pivots):
               They have saved ${data.canvasVersions.length} versions of their business model.
               Summarize the evolution if possible.
               Current Canvas State: ${JSON.stringify(data.canvas)}
               
            2. Customer Discovery:
               They have conducted ${data.customerInterviews.length} interviews.
               Interview Data: ${JSON.stringify(data.customerInterviews.slice(0, 10))}
               Synthesize the findings. What pain points were validated?
               
            STRUCTURE OF THE REPORT:
            - Executive Summary
            - The Journey (Detailing the pivots and evolution of the business model)
            - Customer Insights (Findings from the "Get out of the building" phase)
            - Strategic Outlook (Based on the current canvas and financial model)
            
            Tone: Professional, narrative, and insightful.
            Format: Markdown.
        `;

        return callAI(prompt, "You are a Chief Strategy Officer writing a report for stakeholders.", undefined, undefined, 0, [], args.modelName);
    }
});

export const generateBusinessPlan = action({
    args: {
        startupData: v.any(),
        modelName: v.optional(v.string())
    },
    handler: async (ctx, args) => {
        const data = args.startupData;
        const prompt = `
            Generate a formal, comprehensive Business Plan for this startup based on all available data.
            
            Startup Name: ${data.name}
            Hypothesis: ${data.hypothesis}
            
            DATA SOURCES:
            1. Lean Canvas: ${JSON.stringify(data.canvas)}
            2. Market Research: TAM ${data.market.tam}, SAM ${data.market.sam}, SOM ${data.market.som}.
            3. Financials: 
               - Business Model: ${data.revenueModel.businessModelType}
               - Description: ${data.revenueModel.modelDescription}
               - Projections: Growth ${data.revenueModel.monthlyGrowthRate}%, Churn ${data.revenueModel.churnRate}%
            4. Customer Discovery: ${data.customerInterviews.length} interviews conducted.
            5. Roadmap: ${JSON.stringify(data.features)}
            6. Competitors: ${JSON.stringify(data.competitorAnalysis.competitors.map((c: any) => c.name).join(', '))}
            
            REQUIRED STRUCTURE:
            1. Executive Summary
            2. Company Overview (Mission, Vision, Value Proposition)
            3. Market Analysis (Industry Trends, Target Market, Competition)
            4. Products & Services (Solution Description, Development Roadmap)
            5. Operational Plan (Go-to-Market Strategy)
            6. Financial Plan (Revenue Model, Unit Economics, Projections)
            7. Conclusion
            
            Format: Markdown. Tone: Professional, Investment-grade, Formal.
        `;

        return callAI(prompt, "You are a senior business consultant and venture capitalist writing a formal business plan for potential investors.", undefined, undefined, 0, [], args.modelName);
    }
});

export const generateOKRs = action({
    args: {
        startupData: v.any(),
        modelName: v.optional(v.string())
    },
    handler: async (ctx, args) => {
        const data = args.startupData;
        // Gather context from all modules
        const marketGap = data.market.tam === 0;
        const revenueGap = data.revenueModel.revenueStreams.length === 0;
        const canvasGap = Object.values(data.canvas).some(v => !v);

        // Find potential customers
        const potentialCustomers = data.customerInterviews.filter((c: any) => c.customerStatus === 'Potential Fit');

        const prompt = `
            Generate 3-5 strategic OKRs (Objectives and Key Results) for this startup for the next quarter.
            Review all available data to identify gaps and opportunities.
            
            Startup Name: ${data.name}
            Hypothesis: ${data.hypothesis}
            
            CURRENT STATUS:
            - Market Research: ${marketGap ? "Missing TAM/SAM/SOM" : `TAM $${data.market.tam}`}
            - Revenue Model: ${revenueGap ? "Missing Revenue Streams" : `Defined`}
            - Canvas: ${canvasGap ? "Incomplete" : "Complete"}
            - Customer Pipeline: ${potentialCustomers.length} Potential Fits identified.
            - Build: ${data.features.length} features in roadmap.
            
            INSTRUCTIONS:
            1. If Market/Revenue/Canvas data is missing, prioritize goals to complete them.
            2. If 'Potential Fit' customers exist, create a goal to convert them (e.g., "Close 3 Potential Fits").
            3. Include a Product goal based on the roadmap.
            4. Include a Growth goal based on customer discovery.
            
            Return RAW JSON array of objects:
            [
                {
                    "title": "Objective Title",
                    "type": "Strategic",
                    "timeframe": "Quarterly",
                    "status": "Upcoming",
                    "keyResults": [
                        { "description": "Achieve 100 signups", "target": 100, "unit": "users" },
                        { "description": "Launch MVP", "target": 1, "unit": "launch" }
                    ]
                }
            ]
        `;

        try {
            const text = await callAI(prompt, "You are a product manager setting OKRs.", "application/json",
                {
                    type: Type.ARRAY,
                    items: {
                        type: Type.OBJECT,
                        properties: {
                            title: { type: Type.STRING },
                            type: { type: Type.STRING, enum: ['Strategic', 'Objective'] },
                            timeframe: { type: Type.STRING, enum: ['Weekly', 'Monthly', 'Quarterly'] },
                            status: { type: Type.STRING, enum: ['Upcoming', 'In Progress', 'Completed'] },
                            keyResults: {
                                type: Type.ARRAY,
                                items: {
                                    type: Type.OBJECT,
                                    properties: {
                                        description: { type: Type.STRING },
                                        target: { type: Type.NUMBER },
                                        unit: { type: Type.STRING }
                                    },
                                    required: ['description', 'target', 'unit']
                                }
                            }
                        },
                        required: ['title', 'type', 'timeframe', 'status', 'keyResults']
                    }
                },
                0, [], args.modelName
            );

            const cleanText = text.replace(/```json/g, '').replace(/```/g, '').trim();
            const rawGoals = JSON.parse(cleanText);

            // Add IDs and defaults
            return rawGoals.map((g: any) => ({
                id: Date.now().toString() + Math.random(),
                title: g.title,
                type: g.type,
                timeframe: g.timeframe,
                status: g.status || 'Upcoming',
                linkedCustomerIds: [], // Default empty
                keyResults: g.keyResults.map((kr: any) => ({
                    id: Date.now().toString() + Math.random(),
                    description: kr.description,
                    target: kr.target,
                    current: 0,
                    unit: kr.unit
                }))
            }));

        } catch (e) {
            console.error(e);
            return [];
        }
    }
});
