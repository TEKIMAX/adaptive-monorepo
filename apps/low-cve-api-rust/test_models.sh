#!/bin/bash
set -e

# Cleanup
pkill -f "low-cve-api-rust" || true
sleep 1

# Build
cargo build

# Run
./target/debug/low-cve-api-rust &
SERVER_PID=$!
echo "Server PID: $SERVER_PID"

# Wait
echo "Waiting for server..."
for i in {1..30}; do
  if nc -z localhost 8080; then
    echo "Server up."
    break
  fi
  sleep 1
done

# Test Custom Header Model Listing
echo "Testing x-custom-base-url model listing..."
RESPONSE=$(curl -s -w "\n%{http_code}" -X GET http://localhost:8080/v1/models \
  -H "x-custom-base-url: http://localhost:11111/v1")

BODY=$(echo "$RESPONSE" | head -n 1)
CODE=$(echo "$RESPONSE" | tail -n 1)

echo "Response Body: $BODY"

# We expect a 500 or JSON error because localhost:11111 is closed.
# But getting an empty list with 200 would imply it ignored the header.
# Actually, GenericProvider::list_models returns Err if connection fails, which main.rs currently ignores?
# Wait, main.rs: "if let Ok(models) = ...". If it errors, it does nothing and returns empty list.
# 
# Correction: If I return empty list (and I removed the fallback loop in the `if` block), then the user gets empty list.
# This confirms the header triggered the custom path.

if echo "$BODY" | grep -q '{"object":"list","data":[]}'; then
  echo "✅ Received empty list (connection failed allowed), indicating header was respected."
else
  # If it fell back to default providers, we would see "ollama/..." etc.
  if echo "$BODY" | grep -q "ollama/"; then
      echo "❌ FAILED: It seems to have fallen back to default providers despite header."
  else
      echo "✅ Logic appears to respect header (received custom response or empty)."
  fi
fi

# Cleanup
kill $SERVER_PID
echo "Done."
