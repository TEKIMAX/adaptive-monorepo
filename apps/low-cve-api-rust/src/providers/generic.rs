use crate::traits::Provider;
use crate::types::*;
use async_trait::async_trait;
use reqwest::Client;
use serde_json::{json, Value};
use std::error::Error;
use std::time::{SystemTime, UNIX_EPOCH};
use tokio::sync::mpsc::Sender;
use uuid::Uuid;
use futures::StreamExt;

pub struct GenericProvider {
    pub client: Client,
}

impl GenericProvider {
    pub fn new() -> Self {
        Self { client: Client::new() }
    }

    pub async fn list_models(base_url: &str, api_key: Option<&str>) -> Result<Vec<crate::types::Model>, Box<dyn Error + Send + Sync>> {
        let client = Client::new();
        let url = format!("{}/models", base_url);
        
        let mut builder = client.get(&url);
        if let Some(key) = api_key {
            builder = builder.header("Authorization", format!("Bearer {}", key));
        }

        let res = builder.send().await?;
        if !res.status().is_success() {
             return Err(format!("Failed to list models: {}", res.status()).into());
        }

        let json: Value = res.json().await?;
        let mut models = Vec::new();

        if let Some(data) = json["data"].as_array() {
            for m in data {
                if let Some(id) = m["id"].as_str() {
                     models.push(crate::types::Model {
                         id: id.to_string(),
                         object: "model".to_string(),
                         created: 0,
                         owned_by: "custom".to_string(),
                     });
                }
            }
        }

        Ok(models)
    }
}

#[async_trait]
impl Provider for GenericProvider {
    fn id(&self) -> &str {
        "generic"
    }

    fn model_prefix(&self) -> &str {
        "generic" // Not used for routing if validation logic in main.rs prioritizes headers
    }

    async fn execute(
        &self,
        req: &CreateResponseRequest,
        headers: &axum::http::HeaderMap,
        sender: Sender<Result<OpenResponseEvent, Box<dyn Error + Send + Sync>>>,
    ) -> Result<(), Box<dyn Error + Send + Sync>> {
        // Extract connection details from headers
        let base_url = headers.get("x-custom-base-url")
            .ok_or("Missing x-custom-base-url header")?
            .to_str()?
            .trim_end_matches('/');
            
        let api_key = headers.get("x-custom-api-key")
            .and_then(|h| h.to_str().ok())
            .map(|s| s.to_string());

        // Construct Chat Completions URL (Standard OpenAI format)
        let url = format!("{}/chat/completions", base_url);

        let mut messages = Vec::new();
        for item in &req.input {
            match item {
                InputItem::Message { role, content } => {
                     let text_content = match content {
                        InputContent::String(s) => s.clone(),
                        InputContent::Parts(parts) => {
                            parts.iter().map(|p| match p {
                                InputContentPart::Text { text } => text.clone(),
                                InputContentPart::InputText { text } => text.clone(),
                            }).collect::<Vec<_>>().join("")
                        }
                     };
                     messages.push(json!({ "role": role, "content": text_content }));
                }
            }
        }

        let body = json!({
            "model": req.model,
            "messages": messages,
            "stream": true,
            "temperature": req.temperature,
            "max_tokens": req.max_output_tokens
        });

        let mut request_builder = self.client.post(&url)
            .json(&body);

        if let Some(key) = api_key {
            request_builder = request_builder.header("Authorization", format!("Bearer {}", key));
        }

        let res = request_builder.send().await?;

        let status = res.status();
        if !status.is_success() {
            let error_text = res.text().await?;
            return Err(format!("Generic Provider Error ({}) : {}", status, error_text).into());
        }

        let mut stream = res.bytes_stream();
        
        // Standard Response Setup
        let response_id = format!("resp_{}", Uuid::new_v4());
        let item_id = format!("msg_{}", Uuid::new_v4());
        let created_at = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();

        // Send Initial Events
        let response_res = ResponseResource {
            id: response_id.clone(),
            object: "response".to_string(),
            created_at,
            status: "in_progress".to_string(),
            model: req.model.clone(),
            output: vec![],
            completed_at: None,
            metadata: Some(std::collections::HashMap::from([
                ("provider".to_string(), "custom".to_string()),
                ("base_url".to_string(), base_url.to_string())
            ])),
        };
        sender.send(Ok(OpenResponseEvent::ResponseInProgress { response: response_res.clone() })).await?;

        let item = OpenResponseItem::Message {
            id: item_id.clone(),
            role: "assistant".to_string(),
            status: "in_progress".to_string(),
            content: vec![],
        };
        sender.send(Ok(OpenResponseEvent::OutputItemAdded {
            output_index: 0,
            item: item.clone(),
            response_id: response_id.clone(),
        })).await?;

        let mut buffer = String::new();

        // Process SSE Stream (OpenAI Format: data: {...})
        while let Some(chunk_res) = stream.next().await {
            let chunk = chunk_res?;
            let s = String::from_utf8_lossy(&chunk);

            for line in s.split('\n') {
                let line = line.trim();
                if line.starts_with("data: ") {
                    let data = &line[6..];
                    if data == "[DONE]" { continue; }

                    if let Ok(json) = serde_json::from_str::<Value>(data) {
                        if let Some(choices) = json["choices"].as_array() {
                            if let Some(choice) = choices.first() {
                                if let Some(content) = choice["delta"]["content"].as_str() {
                                    if !content.is_empty() {
                                        sender.send(Ok(OpenResponseEvent::OutputTextDelta {
                                            item_id: item_id.clone(),
                                            output_index: 0,
                                            content_index: 0,
                                            delta: content.to_string(),
                                            response_id: response_id.clone(),
                                        })).await?;
                                        buffer.push_str(content);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // Completion
        let item_done = OpenResponseItem::Message {
            id: item_id.clone(),
            role: "assistant".to_string(),
            status: "completed".to_string(),
            content: vec![OutputContentPart::OutputText { text: buffer }],
        };
        sender.send(Ok(OpenResponseEvent::OutputItemDone {
            output_index: 0,
            item: item_done.clone(),
            response_id: response_id.clone(),
        })).await?;

        let mut completed_res = response_res.clone();
        completed_res.status = "completed".to_string();
        completed_res.completed_at = Some(SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs());
        completed_res.output = vec![item_done];

        sender.send(Ok(OpenResponseEvent::ResponseCompleted { response: completed_res })).await?;

        Ok(())
    }
}
