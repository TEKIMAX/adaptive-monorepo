use crate::traits::Provider;
use crate::types::{CreateResponseRequest, OpenResponseEvent, ResponseResource, ErrorDetails, InputItem, InputContent, InputContentPart};
use async_trait::async_trait;
use reqwest::Client;
use std::error::Error;
use tokio::sync::mpsc::Sender;
use axum::http::HeaderMap;
use serde_json::json;
use futures::StreamExt;
use chrono::Utc;
use uuid::Uuid;

#[derive(Clone)]
pub struct GeminiProvider {
    pub client: Client,
}

impl GeminiProvider {
    pub fn new() -> Self {
        Self {
            client: Client::new(),
        }
    }
}

#[async_trait]
impl Provider for GeminiProvider {
    fn model_prefix(&self) -> &str {
        "gemini"
    }

    async fn list_models(&self) -> Result<Vec<crate::types::Model>, Box<dyn Error + Send + Sync>> {
        Ok(vec![])
    }

    async fn execute(
        &self,
        request: &CreateResponseRequest,
        _headers: &HeaderMap,
        sender: Sender<OpenResponseEvent>,
    ) -> Result<(), Box<dyn Error + Send + Sync>> {
        let api_key = std::env::var("GEMINI_API_KEY").unwrap_or_default();
        
        if api_key.is_empty() {
             let _ = sender.send(OpenResponseEvent::Error { 
                error: ErrorDetails { 
                    code: "config_error".to_string(), 
                    message: "GEMINI_API_KEY not set".to_string()
                }
            }).await;
            return Ok(());
        }
        
        let model_name = if request.model.starts_with("gemini/") {
            request.model.trim_start_matches("gemini/")
        } else {
            &request.model
        };

        let mut contents = Vec::new();
        for item in &request.input {
            if let InputItem::Message { role, content } = item {
                let parts_vec = match content {
                    InputContent::String(s) => vec![json!({ "text": s })],
                    InputContent::Parts(parts) => {
                        parts.iter().map(|p| match p {
                            InputContentPart::Text { text } => json!({ "text": text }),
                            InputContentPart::InputText { text } => json!({ "text": text }),
                            InputContentPart::InlineData { mime_type, data } => json!({
                                "inline_data": {
                                    "mime_type": mime_type,
                                    "data": data
                                }
                            }),
                        }).collect()
                    }
                };
                
                let role_str = if role == "assistant" { "model" } else { "user" }; 
                contents.push(json!({
                    "role": role_str,
                    "parts": parts_vec
                }));
            }
        }

        let url = format!(
            "https://generativelanguage.googleapis.com/v1beta/models/{}:streamGenerateContent?key={}",
            model_name, api_key
        );
        
        let mut body = json!({
            "contents": contents,
            "generationConfig": {
                "temperature": request.temperature,
                "maxOutputTokens": request.max_output_tokens
            }
        });

        // Map Tools
        if let Some(tools) = &request.tools {
             // Gemini expects tools: [{ function_declarations: [...] }]
             // Our Tool struct already matches this structure mostly
             let gemini_tools: Vec<serde_json::Value> = tools.iter().map(|t| {
                 json!({
                     "function_declarations": t.function_declarations
                 })
             }).collect();
             
             if !gemini_tools.is_empty() {
                body["tools"] = json!(gemini_tools);
             }
        }

        let res = self.client.post(&url).json(&body).send().await?;
        
        if !res.status().is_success() {
             let status = res.status();
             let text = res.text().await.unwrap_or_default();
             let _ = sender.send(OpenResponseEvent::Error { 
                error: ErrorDetails { 
                    code: "provider_error".to_string(), 
                    message: format!("Gemini returned {}: {}", status, text)
                }
            }).await;
            return Ok(());
        }

        let response_id = Uuid::new_v4().to_string();
        let _ = sender.send(OpenResponseEvent::ResponseInProgress {
             response: ResponseResource {
                 id: response_id.clone(),
                 object: "response".to_string(),
                 created_at: Utc::now().timestamp() as u64,
                 status: "in_progress".to_string(),
                 model: request.model.clone(),
                 output: vec![],
                 completed_at: None,
                 metadata: None,
             }
        }).await;

        let mut stream = res.bytes_stream();
        let mut buffer = String::new();

        while let Some(chunk_res) = stream.next().await {
             if let Ok(chunk) = chunk_res {
                 let s = String::from_utf8_lossy(&chunk);
                 buffer.push_str(&s);

                 // Gemini stream returns a JSON array: [ {...}, {...} ]
                 // But chunks might be split. We'll try to parse complete JSON objects.
                 // Simple strategy: Split by likely separators or just try to parse if valid
                 // Actually, Gemini typically sends ",\n" or similar between array items.
                 // We will simply try to clean the buffer of '[' and ']' and parse the remaining JSON objects.
                 
                 // Since this is a specialized stream, we know it sends `{\n ... \n}` blocks separated by commas.
                 // A robust parser is complex, but for this "beta" stream:
                 
                 // 1. Remove optional opening '['
                 if buffer.starts_with('[') {
                     buffer.remove(0);
                 }
                 // 2. Remove optional closing ']'
                 if buffer.ends_with(']') {
                     buffer.pop();
                 }
                 
                 // 3. Split by `}\n,` or `},` to find objects? 
                 // It's safer to accumulate and try to parse.
                 // For now, let's assume chunks roughly align or we just scan for matching braces.
                 // "Hack 2.0": Find explicit object boundaries if possible, OR just parse the whole buffer if it forms a valid JSON value? No, it's a stream of objects.
                 
                 // Let's iterate over potential JSON objects in the buffer
                 // This requires a `StreamDeserializer` or manual brace counting.
                 // Manual brace counting:
                 let mut start_idx = 0;
                 let mut brace_count = 0;
                 let mut in_quote = false;
                 let mut escape = false;
                 let mut processed_len = 0;
                 
                 let chars: Vec<char> = buffer.chars().collect();
                 let mut current_obj_str = String::new();
                 
                 for (i, &c) in chars.iter().enumerate() {
                     if escape {
                         escape = false;
                         continue;
                     }
                     if c == '\\' {
                         escape = true;
                         continue;
                     }
                     if c == '"' {
                         in_quote = !in_quote;
                         continue;
                     }
                     
                     if !in_quote {
                         if c == '{' {
                             brace_count += 1;
                         } else if c == '}' {
                             brace_count -= 1;
                             if brace_count == 0 && !current_obj_str.is_empty() {
                                 // Found a complete object?
                                 // Check if we started one
                             }
                         }
                     }
                 }
                 
                 // Revert to a simpler approach: splitting by ",\n" which Gemini usually uses?
                 // Or just `serde_json::Deserializer::from_str(&buffer).into_iter()`? 
                 // That works if the buffer has multiple valid JSONs concatenated (whitespace or no comma).
                 // But valid array items are comma separated.
                 
                 // Let's replace the comma with space to allow concatenated parsing?
                 // Or just try to parse the buffer as a GeminiResponse? Only if it's a single chunk.
                 
                 // **New Strategy**: Simple brace balancing on the raw string is most robust for streams.
                 let mut depth = 0;
                 let mut start = 0;
                 let mut in_string = false;
                 let mut escaping = false;
                 let mut items_found = Vec::new();

                 for (idx, c) in buffer.char_indices() {
                     if escaping { escaping = false; continue; }
                     match c {
                         '\\' => escaping = true,
                         '"' => in_string = !in_string,
                         '{' if !in_string => {
                             if depth == 0 { start = idx; }
                             depth += 1;
                         }
                         '}' if !in_string => {
                             depth -= 1;
                             if depth == 0 {
                                 // Complete object
                                 items_found.push((start, idx + 1));
                             }
                         }
                         _ => {}
                     }
                 }
                 
                 let mut last_processed_byte = 0;
                 
                 for (start, end) in items_found {
                     let json_str = &buffer[start..end];
                     if let Ok(val) = serde_json::from_str::<serde_json::Value>(json_str) {
                         // Process the Gemini Response Part
                         if let Some(candidates) = val.get("candidates").and_then(|c| c.as_array()) {
                             for candidate in candidates {
                                 if let Some(content) = candidate.get("content") {
                                     if let Some(parts) = content.get("parts").and_then(|p| p.as_array()) {
                                         for part in parts {
                                             // 1. Text
                                             if let Some(text) = part.get("text").and_then(|t| t.as_str()) {
                                                 let _ = sender.send(OpenResponseEvent::OutputTextDelta {
                                                     item_id: "0".to_string(),
                                                     output_index: 0,
                                                     content_index: 0,
                                                     delta: text.to_string(),
                                                     response_id: response_id.clone(),
                                                 }).await;
                                             }
                                             // 2. Function Call
                                             if let Some(fc) = part.get("functionCall") {
                                                 let name = fc.get("name").and_then(|n| n.as_str()).unwrap_or_default().to_string();
                                                 let args = fc.get("args").map(|a| a.to_string()).unwrap_or_else(|| "{}".to_string());
                                                 
                                                 let _ = sender.send(OpenResponseEvent::OutputItemAdded {
                                                     output_index: 0,
                                                     item: crate::types::OpenResponseItem::ToolCall {
                                                         id: Uuid::new_v4().to_string(),
                                                         object: "tool_call".to_string(),
                                                         status: "done".to_string(), // Gemini usually sends complete calls? Or parts? Usually complete in one block for now.
                                                         name,
                                                         arguments: args
                                                     },
                                                     response_id: response_id.clone(),
                                                 }).await;
                                             }
                                         }
                                     }
                                 }
                             }
                         }
                         last_processed_byte = end;
                     }
                 }
                 
                 // Truncate buffer to keep only unprocessed bytes (e.g. partial json)
                 if last_processed_byte > 0 {
                     // CAUTION: String slicing works on bytes, but we used char_indices iterator which yields byte indices.
                     // But removing from start of string is expensive. 
                     // Since buffer is small usually, reallocating is fine.
                     if last_processed_byte == buffer.len() {
                         buffer.clear();
                     } else {
                         buffer = buffer[last_processed_byte..].to_string();
                     }
                 }
                 
                 // Handle separators (commas, newlines) remaining at start
                 let trim_chars: &[char] = &[' ', '\n', '\r', ',', '[', ']'];
                 if !buffer.is_empty() {
                    let trimmed = buffer.trim_start_matches(trim_chars);
                    if trimmed.len() != buffer.len() {
                        buffer = trimmed.to_string();
                    }
                 }
             }
        }
        
        Ok(())
    }
}
