use crate::traits::Provider;
use crate::types::*;
use async_trait::async_trait;
use reqwest::Client;
use serde_json::{json, Value};
use std::env;
use std::error::Error;
use std::time::{SystemTime, UNIX_EPOCH};
use tokio::sync::mpsc::Sender;
use uuid::Uuid;
use futures::StreamExt;

pub struct GeminiProvider {
    pub client: Client,
}

impl GeminiProvider {
    pub fn new() -> Self {
        Self { client: Client::new() }
    }
}

#[async_trait]
impl Provider for GeminiProvider {
    fn id(&self) -> &str {
        "gemini"
    }

    fn model_prefix(&self) -> &str {
        "gemini" // matches 'gemini-1.5-flash', etc.
    }

    async fn execute(
        &self,
        req: &CreateResponseRequest,
        _headers: &axum::http::HeaderMap,
        sender: Sender<Result<OpenResponseEvent, Box<dyn Error + Send + Sync>>>,
    ) -> Result<(), Box<dyn Error + Send + Sync>> {
        let api_key = env::var("GEMINI_API_KEY").map_err(|_| "GEMINI_API_KEY not found")?;
        
        // Normalize Input
        let mut messages = Vec::new();
        for item in &req.input {
            match item {
                InputItem::Message { role, content } => {
                     let text_content = match content {
                        InputContent::String(s) => s.clone(),
                        InputContent::Parts(parts) => {
                            parts.iter().map(|p| match p {
                                InputContentPart::Text { text } => text.clone(),
                                InputContentPart::InputText { text } => text.clone(),
                            }).collect::<Vec<_>>().join("")
                        }
                     };
                     messages.push(json!({ "role": role, "content": text_content }));
                }
            }
        }

        let body = json!({
            "model": req.model,
            "messages": messages,
            "stream": true,
            "temperature": req.temperature,
            "max_tokens": req.max_output_tokens,
        });

        // Google Gemini OpenAI-compatible endpoint
        let endpoint = "https://generativelanguage.googleapis.com/v1beta/openai/chat/completions";

        let res = self.client.post(endpoint)
            .header("Authorization", format!("Bearer {}", api_key))
            .json(&body)
            .send()
            .await?;

        if !res.status().is_success() {
            let error_text = res.text().await?;
            return Err(format!("Gemini API Error: {}", error_text).into());
        }

        let mut stream = res.bytes_stream();

        let response_id = format!("resp_{}", Uuid::new_v4());
        let item_id = format!("msg_{}", Uuid::new_v4());
        let created_at = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();

        let response_res = ResponseResource {
            id: response_id.clone(),
            object: "response".to_string(),
            created_at,
            status: "in_progress".to_string(),
            model: req.model.clone(),
            output: vec![],
            completed_at: None,
            metadata: Some(std::collections::HashMap::from([
                ("provider".to_string(), "gemini".to_string())
            ])),
        };

        // Send Initial Event
        sender.send(Ok(OpenResponseEvent::ResponseInProgress { response: response_res.clone() })).await?;

        // Send Item Added
        let item = OpenResponseItem::Message {
            id: item_id.clone(),
            role: "assistant".to_string(),
            status: "in_progress".to_string(),
            content: vec![],
        };
        sender.send(Ok(OpenResponseEvent::OutputItemAdded {
            output_index: 0,
            item: item.clone(),
            response_id: response_id.clone(),
        })).await?;

        let mut buffer = String::new();

        while let Some(chunk_res) = stream.next().await {
            let chunk = chunk_res?;
            let s = String::from_utf8_lossy(&chunk);
            
            for line in s.lines() {
                if line.starts_with("data: ") {
                    let data_str = &line[6..];
                    if data_str.trim() == "[DONE]" { continue; }

                    if let Ok(json) = serde_json::from_str::<Value>(data_str) {
                         if let Some(delta) = json["choices"][0]["delta"]["content"].as_str() {
                             if !delta.is_empty() {
                                 // Send Delta
                                 sender.send(Ok(OpenResponseEvent::OutputTextDelta {
                                     item_id: item_id.clone(),
                                     output_index: 0,
                                     content_index: 0,
                                     delta: delta.to_string(),
                                     response_id: response_id.clone(),
                                 })).await?;
                                 buffer.push_str(delta);
                             }
                         }
                    }
                }
            }
        }

        // Send Item Done
        let item_done = OpenResponseItem::Message {
            id: item_id.clone(),
            role: "assistant".to_string(),
            status: "completed".to_string(),
            content: vec![OutputContentPart::OutputText { text: buffer }],
        };
        sender.send(Ok(OpenResponseEvent::OutputItemDone {
            output_index: 0,
            item: item_done.clone(),
            response_id: response_id.clone(),
        })).await?;

        // Send Response Completed
        let mut completed_res = response_res.clone();
        completed_res.status = "completed".to_string();
        completed_res.completed_at = Some(SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs());
        completed_res.output = vec![item_done];

        sender.send(Ok(OpenResponseEvent::ResponseCompleted { response: completed_res })).await?;

        Ok(())
    }
}
