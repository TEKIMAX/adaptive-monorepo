mod config;
mod middleware;
mod providers;
mod traits;
mod types;

use axum::{
    extract::{Json, State},
    response::Sse,
    routing::{get, post},
    Router,
};
use futures::stream::Stream;
use std::convert::Infallible;
use std::net::SocketAddr;
use std::sync::Arc;
use tokio::sync::mpsc;
use tokio_stream::wrappers::ReceiverStream;
use tower_http::cors::CorsLayer;

use crate::config::providers::get_configured_providers;
use crate::middleware::{auth_middleware, cost_middleware};
use crate::types::{CreateResponseRequest, OpenResponseEvent};

struct AppState {
    providers: Vec<crate::config::providers::ProviderConfig>,
}

#[tokio::main]
async fn main() {
    // Load env
    dotenv::dotenv().ok();

    let state = Arc::new(AppState {
        providers: get_configured_providers(),
    });

    let app = Router::new()
        .route("/health", get(|| async { "OK" }))
        .route("/v1/responses", post(create_response))
        .route("/v1/models", get(list_models))
        .route("/openapi.json", get(openapi_spec))
        .route("/docs", get(scalar_docs))
        .layer(axum::middleware::from_fn(auth_middleware))
        .layer(axum::middleware::from_fn(cost_middleware))
        .layer(CorsLayer::permissive())
        .with_state(state);

    let port = std::env::var("PORT").unwrap_or_else(|_| "8080".to_string());
    let addr: SocketAddr = format!("0.0.0.0:{}", port).parse().unwrap();
    
    println!("Server running on {}", addr);
    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

async fn create_response(
    State(state): State<Arc<AppState>>,
    headers: axum::http::HeaderMap,
    Json(payload): Json<CreateResponseRequest>,
) -> Sse<impl Stream<Item = Result<axum::response::sse::Event, Infallible>>> {
    
    let (tx, rx) = mpsc::channel(100);
    
    // Check for custom provider headers first
    let provider: Option<Arc<dyn crate::traits::Provider>> = if headers.contains_key("x-custom-base-url") {
        Some(Arc::new(crate::providers::generic::GenericProvider::new()))
    } else {
        // Fallback to configured providers based on model prefix
        state.providers.iter()
            .find(|p| payload.model.starts_with(&p.model_prefix))
            .map(|p| p.provider.clone())
    };

    // Clone headers to move into async block
    let headers = headers.clone();

    tokio::spawn(async move {
        if let Some(p) = provider {
            let (internal_tx, mut internal_rx) = mpsc::channel(100);
            
            tokio::spawn(async move {
                if let Err(e) = p.execute(&payload, &headers, internal_tx.clone()).await {
                   eprintln!("Provider Error: {}", e);
                   
                   let error_event = crate::types::OpenResponseEvent::Error {
                       error: crate::types::ErrorDetails {
                           code: "provider_error".to_string(),
                           message: e.to_string(),
                       }
                   };
                   let _ = internal_tx.send(Ok(error_event)).await;
                }
            });

            while let Some(result) = internal_rx.recv().await {
                match result {
                    Ok(event) => {
                        let json = serde_json::to_string(&event).unwrap();
                        let _ = tx.send(Ok(axum::response::sse::Event::default().data(json))).await;
                    }
                    Err(e) => {
                         eprintln!("Stream Error: {}", e);
                         break;
                    }
                }
            }
        } else {
             let _ = tx.send(Ok(axum::response::sse::Event::default().data("Provider not found"))).await;
        }
    });

    Sse::new(ReceiverStream::new(rx))
        .keep_alive(axum::response::sse::KeepAlive::default())
}

async fn list_models(
    State(state): State<Arc<AppState>>,
    headers: axum::http::HeaderMap,
) -> Json<crate::types::ListModelsResponse> {
    let mut all_models = Vec::new();

    // Check for custom provider headers
    if let Some(base_url_header) = headers.get("x-custom-base-url") {
        if let Ok(base_url) = base_url_header.to_str() {
            let api_key = headers.get("x-custom-api-key")
                .and_then(|h| h.to_str().ok());
            
            let url = base_url.trim_end_matches('/');
            if let Ok(models) = crate::providers::generic::GenericProvider::list_models(url, api_key).await {
                all_models.extend(models);
            }
        }
    } else {
        // Fallback to configured providers
        for config in &state.providers {
            if let Ok(models) = config.provider.list_models().await {
                all_models.extend(models);
            }
        }
    }

    Json(crate::types::ListModelsResponse {
        object: "list".to_string(),
        data: all_models,
    })
}

async fn openapi_spec(
    State(state): State<Arc<AppState>>,
) -> impl axum::response::IntoResponse {
    let mut spec: serde_json::Value = serde_json::from_str(include_str!("openapi.json")).unwrap();

    // Dynamically fetch models
    let mut all_models = Vec::new();
    for config in &state.providers {
        if let Ok(models) = config.provider.list_models().await {
            all_models.extend(models);
        }
    }
    
    // Add models to enum
    let model_ids: Vec<String> = all_models.iter().map(|m| m.id.clone()).collect();
    if !model_ids.is_empty() {
         if let Some(s) = spec.get_mut("components")
             .and_then(|c| c.get_mut("schemas"))
             .and_then(|s| s.get_mut("CreateResponseRequest"))
             .and_then(|r| r.get_mut("properties"))
             .and_then(|p| p.get_mut("model")) {
                 s["enum"] = serde_json::json!(model_ids);
         }
    }

    axum::response::Response::builder()
        .header("Content-Type", "application/json")
        .body(spec.to_string())
        .unwrap()
}

async fn scalar_docs() -> axum::response::Html<&'static str> {
    axum::response::Html(
        r#"<!doctype html>
        <html>
          <head>
            <title>Low CVE API Reference</title>
            <meta charset="utf-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            <style>
              body { margin: 0; }
            </style>
          </head>
          <body>
            <script
              id="api-reference"
              data-url="/openapi.json"
            ></script>
            <script src="https://cdn.jsdelivr.net/npm/@scalar/api-reference"></script>
          </body>
        </html>"#
    )
}
