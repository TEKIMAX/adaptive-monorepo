use axum::{
    extract::{ws::{Message, WebSocket, WebSocketUpgrade}, State},
    response::IntoResponse,
};
use futures_util::{StreamExt, SinkExt};
use std::sync::Arc;
use tokio_tungstenite::{connect_async, tungstenite::protocol::Message as TungsteniteMessage};
use url::Url;

pub async fn realtime_handler(
    ws: WebSocketUpgrade,
    State(_state): State<Arc<crate::AppState>>,
) -> impl IntoResponse {
    ws.on_upgrade(handle_socket)
}

async fn handle_socket(mut client_socket: WebSocket) {
    let api_key = std::env::var("GEMINI_API_KEY").unwrap_or_default();
    let model = "gemini-2.0-flash-exp"; 
    // WebSocket URL for Gemini Live
    let google_url = format!(
        "wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1alpha.GenerativeService.BidiGenerateContent?key={}",
        api_key
    );

    let url = Url::parse(&google_url).expect("Bad Google URL");

    // Connect to Google
    let (ws_stream, _) = connect_async(url).await.expect("Failed to connect to Google");
    let (mut google_write, mut google_read) = ws_stream.split();
    let (mut client_write, mut client_read) = client_socket.split();

    let mut send_task = tokio::spawn(async move {
        while let Some(msg) = client_read.next().await {
            if let Ok(msg) = msg {
                 match msg {
                     Message::Text(text) => {
                         // Forward text message to Google
                         if let Err(_) = google_write.send(TungsteniteMessage::Text(text)).await { break; }
                     },
                     Message::Binary(bin) => {
                         // Forward binary (audio) to Google
                         if let Err(_) = google_write.send(TungsteniteMessage::Binary(bin)).await { break; }
                     },
                     Message::Close(_) => {
                         let _ = google_write.close().await;
                         break;
                     },
                     _ => {}
                 }
            } else {
                break;
            }
        }
    });

    let mut recv_task = tokio::spawn(async move {
        while let Some(msg) = google_read.next().await {
            if let Ok(msg) = msg {
                match msg {
                    TungsteniteMessage::Text(text) => {
                        if let Err(_) = client_write.send(Message::Text(text)).await { break; }
                    },
                    TungsteniteMessage::Binary(bin) => {
                        if let Err(_) = client_write.send(Message::Binary(bin)).await { break; }
                    },
                    TungsteniteMessage::Close(_) => {
                        let _ = client_write.close().await;
                        break;
                    },
                    _ => {}
                }
            } else {
                break;
            }
        }
    });

    tokio::select! {
        _ = (&mut send_task) => recv_task.abort(),
        _ = (&mut recv_task) => send_task.abort(),
    };
}
