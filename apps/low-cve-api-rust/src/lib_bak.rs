use worker::*;
use crate::config::providers::get_configured_providers;
use crate::types::{CreateResponseRequest, OpenResponseEvent};
use futures::StreamExt;
use futures::channel::mpsc;
use std::sync::Arc;

mod config;
mod providers;
mod traits;
mod types;

#[event(fetch)]
pub async fn main(req: Request, env: Env, _ctx: worker::Context) -> Result<Response> {
    
    // Enable CORS
    let router = Router::with_data(env.clone());

    router
        .get("/", |_, _| Response::ok("Adaptive API Rust (Wasm) is Running"))
        .get("/health", |_, _| Response::ok("OK"))
        .get_async("/v1/models", list_models)
        .post_async("/v1/responses", create_response)
        .options("/*params", |_, _| {
             Response::empty()?.with_cors(&Cors::new().with_origins(vec!["*"]).with_methods(vec![Method::Post, Method::Get, Method::Options]))
        })
        .run(req, env)
        .await
        .map(|res| res.with_cors(&Cors::new().with_origins(vec!["*"]).with_methods(vec![Method::Post, Method::Get, Method::Options])).unwrap())

}

async fn list_models(_req: Request, ctx: RouteContext<Env>) -> Result<Response> {
    let providers = get_configured_providers();
    let mut all_models = Vec::new();
    
    for config in providers {
        if let Ok(models) = config.provider.list_models(&ctx.env).await {
             all_models.extend(models);
        }
    }
    
    Response::from_json(&crate::types::ListModelsResponse {
        object: "list".to_string(),
        data: all_models,
    })
}

async fn create_response(mut req: Request, ctx: RouteContext<Env>) -> Result<Response> {
    let payload = match req.json::<CreateResponseRequest>().await {
        Ok(p) => p,
        Err(e) => return Response::error(format!("Invalid JSON: {}", e), 400),
    };
    
    let providers = get_configured_providers();
    
    // Find provider based on model prefix
    let provider_config = providers.iter()
        .find(|p| payload.model.starts_with(&p.model_prefix));

    let provider = match provider_config {
        Some(p) => p.provider.clone(),
        None => return Response::error("Provider not found for model", 404),
    };

    // Create channel
    let (tx, rx) = mpsc::channel(100);
    
    // Spawn execution
    let headers = req.headers().clone();
    let env = ctx.env.clone();
    
    wasm_bindgen_futures::spawn_local(async move {
        // Trigger execution
        let _ = provider.execute(&payload, &headers, &env, tx).await;
        // Errors are sent via channel or just dropped (channel closed)
    });

    // Convert Receiver to Stream of Bytes (SSE)
    let stream = rx.map(|result| {
        match result {
            Ok(event) => {
                let json = serde_json::to_string(&event).unwrap_or_default();
                // SSE format: data: <json>\n\n
                Ok::<Vec<u8>, worker::Error>(format!("data: {}\n\n", json).into_bytes())
            },
            Err(e) => {
                // Send error event
                Ok::<Vec<u8>, worker::Error>(format!("event: error\ndata: {}\n\n", e).into_bytes())
            }
        }
    });

    // Valid SSE response using Response::from_stream
    // Ensure the stream type matches what worker expects: Stream<Item = Result<Vec<u8>, Error>>
    // My stream yields Result<Vec<u8>, Box<dyn Error>>? No, it yields Result<Vec<u8>, ...> because correct mapping.
    // Wait, the closure returns Ok(...). So the stream items are Result<Vec<u8>, _>. The Error type??
    // It infers.
    // Explicitly cast or map_err if needed.
    let mut response = Response::from_stream(stream)?;
    response.headers_mut().set("Content-Type", "text/event-stream")?;
    response.headers_mut().set("Cache-Control", "no-cache")?;
    response.headers_mut().set("Connection", "keep-alive")?;
    
    Ok(response)
}
